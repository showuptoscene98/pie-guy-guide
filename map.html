<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<title>Map Overlay</title>
<style>
  html, body { height:100%; }
  body {
    margin:0;
    background: transparent;
    color:#fff;
    font-family:Arial, sans-serif;
    overflow:hidden;
  }

  .titlebar {
    height: 64px;
    background: rgba(0, 0, 0, 0.85);
    display:flex;
    flex-direction:column;
    padding: 8px 10px;
    -webkit-app-region: drag;
    user-select:none;
  }

  .toprow{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
  }

  .map-layout {
    display: flex;
    height: calc(100vh - 64px);
    -webkit-app-region: no-drag;
  }

  .map-sidebar {
    width: 160px;
    flex-shrink: 0;
    background: transparent;
    border-right: 1px solid rgba(255,255,255,0.08);
    padding: 10px;
    display: flex;
    flex-direction: column;
    gap: 14px;
  }

  .map-sidebar label {
    font-size: 11px;
    color: rgba(255,255,255,0.8);
    display: block;
    margin-bottom: 4px;
  }

  .map-sidebar select {
    width: 100%;
    padding: 6px 8px;
    font-size: 12px;
    background: #222;
    border: 1px solid rgba(255,255,255,0.2);
    border-radius: 8px;
    color: #fff;
    cursor: pointer;
  }

  .map-sidebar select:focus {
    outline: none;
    border-color: rgba(255,204,77,0.5);
  }

  .map-opacity-wrap {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .map-opacity-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 8px;
  }

  .map-opacity-value {
    font-size: 11px;
    color: rgba(255,255,255,0.7);
    min-width: 32px;
    text-align: right;
  }

  .map-opacity-slider {
    width: 100%;
    height: 6px;
    -webkit-appearance: none;
    appearance: none;
    background: rgba(255,255,255,0.15);
    border-radius: 3px;
  }

  .map-opacity-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: #ffcc4d;
    cursor: pointer;
    border: none;
  }

  .map-opacity-slider::-moz-range-thumb {
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: #ffcc4d;
    cursor: pointer;
    border: none;
  }

  .btn {
    padding: 4px 8px;
    font-size: 11px;
    border-radius: 8px;
    border: 1px solid rgba(255,255,255,0.2);
    background: #222;
    color: #fff;
    cursor: pointer;
  }
  .btn:hover { background: #333; }

  .stage-wrap {
    flex: 1;
    min-width: 0;
    position: relative;
  }

  .stage {
    width: 100%;
    height: 100%;
    overflow:hidden;
    position: absolute;
    left: 0;
    top: 0;
    right: 0;
    bottom: 0;
    overflow: hidden;
    touch-action: none;
    background: transparent;
  }

  .canvas {
    position:absolute;
    left:0;
    top:0;
    transform-origin:0 0;
    cursor:grab;
    display:inline-block;
  }
  .canvas.dragging { cursor:grabbing; }

  .player-icon {
    position:absolute;
    width:20px;
    height:20px;
    margin-left:-10px;
    margin-top:-10px;
    border-radius:50%;
    background:#00cc66;
    border:2px solid #fff;
    box-shadow:0 0 6px rgba(0,0,0,0.8);
    cursor:grab;
    z-index:2;
  }
  .player-icon.dragging { cursor:grabbing; }
  .player-icon.hidden { display:none; }
  .map-sidebar .minimap-track-wrap { margin-top:8px; }
  .map-sidebar .minimap-track-wrap label { display:flex; align-items:center; gap:6px; cursor:pointer; font-size:12px; }

  img {
    display:block;
    max-width:none; /* allow zooming bigger than viewport */
    user-select:none;
    -webkit-user-drag:none;
    pointer-events:none; /* IMPORTANT: stage gets all input */
  }

  .hint{
    font-size:12px;
    color:rgba(255,255,255,0.70);
    margin-top:2px;
  }

  .clickthrough-wrap {
    display: flex;
    align-items: center;
    gap: 8px;
    -webkit-app-region: no-drag;
  }
  .clickthrough-wrap label {
    font-size: 12px;
    cursor: pointer;
    user-select: none;
  }

  /* Map-only mode (F6): show "Map only" strip (draggable), hide full title bar and sidebar */
  .map-only-bar {
    display: none;
    height: 28px;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    color: rgba(255,255,255,0.9);
    text-shadow: 0 0 4px #000, 0 1px 2px #000;
    -webkit-app-region: drag;
    user-select: none;
  }
  body.titlebar-transparent .titlebar {
    height: 28px;
    min-height: 28px;
    padding: 0;
    background: transparent;
    justify-content: center;
  }
  body.titlebar-transparent .titlebar .toprow {
    display: none;
  }
  body.titlebar-transparent .titlebar .map-only-bar {
    display: flex;
  }
  body.titlebar-transparent .map-layout {
    height: calc(100vh - 28px);
  }
  body.titlebar-transparent .map-sidebar {
    width: 0;
    min-width: 0;
    padding: 0;
    overflow: hidden;
    border: none;
  }
  body.titlebar-transparent .titlebar .toprow > div:first-child > div:first-child,
  body.titlebar-transparent .titlebar .hint,
  body.titlebar-transparent .titlebar .clickthrough-wrap label,
  body.titlebar-transparent .titlebar .btn {
    text-shadow: 0 0 4px #000, 0 1px 2px #000;
  }
</style>
</head>
<body tabindex="0">

<div class="titlebar">
  <div class="map-only-bar" aria-hidden="true">Map only</div>
  <div class="toprow">
    <div>
      <div style="font-weight:900;">Maps</div>
      <div class="hint">Drag to pan • Mouse wheel zooms • ESC closes • F6 show map selection &amp; window • F8 click-through</div>
    </div>
    <div class="clickthrough-wrap">
      <input type="checkbox" id="clickthroughCheck" />
      <label for="clickthroughCheck">Click-through</label>
    </div>
    <button class="btn" style="-webkit-app-region:no-drag;" onclick="window.api.closeOverlay()">Close</button>
  </div>
</div>

<div class="map-layout">
  <aside class="map-sidebar">
    <div>
      <label for="mapSelect">Map</label>
      <select id="mapSelect" aria-label="Select map"></select>
    </div>
    <div>
      <button type="button" class="btn" id="setCurrentZoneBtn" style="width:100%;">Set as current zone</button>
    </div>
    <div class="map-opacity-wrap">
      <label for="mapOpacitySlider">Opacity</label>
      <div class="map-opacity-row">
        <input type="range" id="mapOpacitySlider" class="map-opacity-slider" min="30" max="100" value="100" />
        <span class="map-opacity-value" id="mapOpacityValue">100%</span>
      </div>
    </div>
    <div class="minimap-track-wrap">
      <label>
        <input type="checkbox" id="minimapTrackCheck" />
        <span>Track from game minimap</span>
      </label>
    </div>
  </aside>
  <div class="stage-wrap">
    <div class="stage" id="stage">
      <div class="canvas" id="canvas">
        <img id="mapImage" src="" draggable="false" alt="Map" />
        <div class="player-icon hidden" id="playerIcon" title="You are here" aria-hidden="true"></div>
      </div>
    </div>
  </div>
</div>

<script>
  // Hard-disable right click + drag-out
  window.addEventListener("contextmenu", (e) => e.preventDefault());
  window.addEventListener("dragstart", (e) => e.preventDefault());

  // Ensure keyboard focus so ESC always works
  function forceFocus(){
    document.body.focus();
    window.focus();
  }
  window.addEventListener("load", forceFocus);
  window.addEventListener("focus", forceFocus);
  document.addEventListener("mousedown", forceFocus);

  // ESC close (use window keydown for reliability)
  window.addEventListener("keydown", (e) => {
    if (e.key === "Escape") window.api.closeOverlay();
  });

  // Click-through option (F8 toggles when overlay can't be clicked)
  const clickthroughCheck = document.getElementById("clickthroughCheck");
  if (clickthroughCheck && window.api) {
    clickthroughCheck.addEventListener("change", () => {
      window.api.setOverlayClickthrough(clickthroughCheck.checked);
    });
    window.api.onOverlayClickthroughState?.((value) => {
      clickthroughCheck.checked = !!value;
    });
  }

  // F6: title bar transparent / visible
  function setTitleBarVisible(visible) {
    document.body.classList.toggle("titlebar-transparent", !visible);
  }
  if (window.api) {
    window.api.getOverlayTitleBarVisible?.().then(setTitleBarVisible);
    window.api.onOverlayTitleBarVisible?.(setTitleBarVisible);
  }

  const maps = [
    "AnagogeIsland",
    "Eltibule",
    "Fae Realm",
    "Gazluk",
    "Ilmari",
    "Kur Mountains",
    "Povus",
    "Rahu",
    "Serbule",
    "SerbuleHills",
    "Sun Vale"
  ];

  const mapSelect = document.getElementById("mapSelect");
  const mapImage = document.getElementById("mapImage");
  const stage = document.getElementById("stage");
  const canvas = document.getElementById("canvas");
  const mapOpacitySlider = document.getElementById("mapOpacitySlider");
  const mapOpacityValue = document.getElementById("mapOpacityValue");

  let scale = 0.8;
  let x = 40;
  let y = 40;

  function applyTransform(){
    canvas.style.transform = `translate(${x}px, ${y}px) scale(${scale})`;
  }

  const MAP_SIDEBAR_WIDTH = 160;

  function loadMap(name){
    mapImage.onload = function(){
      if (window.api && window.api.setOverlaySize && mapImage.naturalWidth && mapImage.naturalHeight) {
        window.api.setOverlaySize(MAP_SIDEBAR_WIDTH + mapImage.naturalWidth, mapImage.naturalHeight);
      }
      loadPlayerIconPosition();
    };
    mapImage.src = `maps/${name}.jpg`;
    scale = 0.8; x = 40; y = 40;
    applyTransform();
  }

  // Populate dropdown
  maps.forEach((name) => {
    const opt = document.createElement("option");
    opt.value = name;
    opt.textContent = name;
    mapSelect.appendChild(opt);
  });

  mapSelect.addEventListener("change", () => loadMap(mapSelect.value));

  const setCurrentZoneBtn = document.getElementById("setCurrentZoneBtn");
  if (setCurrentZoneBtn && window.api?.setCurrentMapZone) {
    setCurrentZoneBtn.addEventListener("click", () => {
      window.api.setCurrentMapZone(mapSelect.value);
    });
  }

  // Opacity slider
  if (mapOpacitySlider && window.api && window.api.setOverlayOpacity) {
    mapOpacitySlider.addEventListener("input", () => {
      const pct = mapOpacitySlider.value;
      if (mapOpacityValue) mapOpacityValue.textContent = pct + "%";
      window.api.setOverlayOpacity(Number(pct) / 100);
    });
  }

  loadMap(maps[0]);
  mapSelect.value = maps[0];

  // Player icon: position (normalized 0-1), draggable, show when zone matches
  const playerIcon = document.getElementById("playerIcon");
  let currentMapZoneFromApp = "";
  let playerIconNorm = { x: 0.5, y: 0.5 };
  let iconDragging = false;
  let iconDragStart = { px: 0, py: 0, nx: 0.5, ny: 0.5 };

  function applyPlayerIconPosition() {
    if (!playerIcon || !mapImage.naturalWidth || !mapImage.naturalHeight) return;
    const nx = Math.max(0, Math.min(1, playerIconNorm.x));
    const ny = Math.max(0, Math.min(1, playerIconNorm.y));
    playerIcon.style.left = (nx * mapImage.naturalWidth) + "px";
    playerIcon.style.top = (ny * mapImage.naturalHeight) + "px";
  }

  function updatePlayerIconVisibility() {
    if (!playerIcon) return;
    const zoneMatch = currentMapZoneFromApp && mapSelect.value === currentMapZoneFromApp;
    const trackingOn = minimapTrackCheck && minimapTrackCheck.checked;
    const show = zoneMatch || trackingOn;
    playerIcon.classList.toggle("hidden", !show);
    if (show) applyPlayerIconPosition();
  }

  function loadPlayerIconPosition() {
    const zone = mapSelect.value;
    if (!zone || !window.api?.getPlayerIconPosition) return;
    window.api.getPlayerIconPosition("map", zone).then((pos) => {
      if (pos && typeof pos.x === "number" && typeof pos.y === "number") {
        playerIconNorm.x = pos.x;
        playerIconNorm.y = pos.y;
      } else {
        playerIconNorm.x = 0.5;
        playerIconNorm.y = 0.5;
      }
      applyPlayerIconPosition();
    });
  }

  function savePlayerIconPosition() {
    const zone = mapSelect.value;
    if (!zone || !window.api?.setPlayerIconPosition) return;
    window.api.setPlayerIconPosition("map", zone, playerIconNorm.x, playerIconNorm.y);
  }

  if (playerIcon) {
    playerIcon.addEventListener("pointerdown", (e) => {
      if (e.button !== 0 || !currentMapZoneFromApp || mapSelect.value !== currentMapZoneFromApp) return;
      e.preventDefault();
      e.stopPropagation();
      iconDragging = true;
      playerIcon.setPointerCapture(e.pointerId);
      playerIcon.classList.add("dragging");
      iconDragStart = { px: e.clientX, py: e.clientY, nx: playerIconNorm.x, ny: playerIconNorm.y };
    });
  }
  stage.addEventListener("pointermove", (e) => {
    if (!iconDragging || !mapImage.naturalWidth || !mapImage.naturalHeight) return;
    const dx = (e.clientX - iconDragStart.px) / scale;
    const dy = (e.clientY - iconDragStart.py) / scale;
    const w = mapImage.naturalWidth;
    const h = mapImage.naturalHeight;
    playerIconNorm.x = Math.max(0, Math.min(1, iconDragStart.nx + dx / w));
    playerIconNorm.y = Math.max(0, Math.min(1, iconDragStart.ny + dy / h));
    applyPlayerIconPosition();
  });
  stage.addEventListener("pointerup", () => {
    if (iconDragging) {
      iconDragging = false;
      playerIcon.classList.remove("dragging");
      savePlayerIconPosition();
    }
  });
  stage.addEventListener("pointercancel", () => {
    if (iconDragging) {
      iconDragging = false;
      playerIcon.classList.remove("dragging");
    }
  });

  function applyZoneFromApp(zone) {
    currentMapZoneFromApp = zone || "";
    if (zone && maps.includes(zone) && mapSelect.value !== zone) {
      mapSelect.value = zone;
      loadMap(zone);
    }
    updatePlayerIconVisibility();
    loadPlayerIconPosition();
  }
  if (window.api) {
    window.api.getCurrentMapZone?.().then(applyZoneFromApp);
    window.api.onCurrentMapZone?.(applyZoneFromApp);
    window.api.onOverlaySwitchToMap?.((zone) => {
      if (zone && maps.includes(zone)) {
        mapSelect.value = zone;
        loadMap(zone);
        currentMapZoneFromApp = zone;
        updatePlayerIconVisibility();
        loadPlayerIconPosition();
      }
    });
  }
  mapSelect.addEventListener("change", () => {
    updatePlayerIconVisibility();
    loadPlayerIconPosition();
  });

  // Minimap tracking: capture game window, crop minimap region, template match on map
  const minimapTrackCheck = document.getElementById("minimapTrackCheck");
  let minimapTrackInterval = null;
  let minimapVideo = null;
  let minimapStream = null;
  const MINIMAP_REGION = { x: 0.78, y: 0.05, w: 0.2, h: 0.2 };
  const MAP_DOWNSCALE = 128;
  const MINIMAP_PATCH = 24;
  const SEARCH_STEP = 4;

  function stopMinimapTracking() {
    if (minimapTrackInterval) {
      clearInterval(minimapTrackInterval);
      minimapTrackInterval = null;
    }
    if (minimapStream) {
      minimapStream.getTracks().forEach((t) => t.stop());
      minimapStream = null;
    }
    if (minimapVideo && minimapVideo.srcObject) {
      minimapVideo.srcObject = null;
    }
    updatePlayerIconVisibility();
  }

  function grayscaleSample(ctx, x, y, w, h) {
    const data = ctx.getImageData(x, y, w, h).data;
    const out = new Float32Array(w * h);
    for (let i = 0; i < data.length; i += 4) {
      out[i / 4] = (data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114) / 255;
    }
    return out;
  }

  function runMinimapTrack() {
    if (!minimapVideo || !mapImage.complete || !mapImage.naturalWidth) return;
    const vw = minimapVideo.videoWidth;
    const vh = minimapVideo.videoHeight;
    if (!vw || !vh) return;
    const rx = Math.floor(MINIMAP_REGION.x * vw);
    const ry = Math.floor(MINIMAP_REGION.y * vh);
    const rw = Math.max(8, Math.floor(MINIMAP_REGION.w * vw));
    const rh = Math.max(8, Math.floor(MINIMAP_REGION.h * vh));
    if (rx + rw > vw || ry + rh > vh) return;

    const mapW = mapImage.naturalWidth;
    const mapH = mapImage.naturalHeight;

    const capCanvas = document.createElement("canvas");
    capCanvas.width = vw;
    capCanvas.height = vh;
    const capCtx = capCanvas.getContext("2d");
    capCtx.drawImage(minimapVideo, 0, 0);
    const mmSmall = document.createElement("canvas");
    mmSmall.width = MINIMAP_PATCH;
    mmSmall.height = MINIMAP_PATCH;
    mmSmall.getContext("2d").drawImage(capCanvas, rx, ry, rw, rh, 0, 0, MINIMAP_PATCH, MINIMAP_PATCH);
    const minimapPixels = grayscaleSample(mmSmall.getContext("2d"), 0, 0, MINIMAP_PATCH, MINIMAP_PATCH);

    const mapSmall = document.createElement("canvas");
    mapSmall.width = MAP_DOWNSCALE;
    mapSmall.height = Math.round(MAP_DOWNSCALE * (mapH / mapW));
    const mapSmallH = mapSmall.height;
    mapSmall.getContext("2d").drawImage(mapImage, 0, 0, mapW, mapH, 0, 0, MAP_DOWNSCALE, mapSmallH);
    const mapPixels = grayscaleSample(mapSmall.getContext("2d"), 0, 0, MAP_DOWNSCALE, mapSmallH);

    let bestSx = 0, bestSy = 0, bestSad = Infinity;
    for (let sy = 0; sy + MINIMAP_PATCH <= mapSmallH; sy += SEARCH_STEP) {
      for (let sx = 0; sx + MINIMAP_PATCH <= MAP_DOWNSCALE; sx += SEARCH_STEP) {
        let sad = 0;
        for (let my = 0; my < MINIMAP_PATCH; my++) {
          for (let mx = 0; mx < MINIMAP_PATCH; mx++) {
            const mapIdx = (sy + my) * MAP_DOWNSCALE + (sx + mx);
            const mmIdx = my * MINIMAP_PATCH + mx;
            sad += Math.abs((mapPixels[mapIdx] || 0) - (minimapPixels[mmIdx] || 0));
          }
        }
        if (sad < bestSad) {
          bestSad = sad;
          bestSx = sx;
          bestSy = sy;
        }
      }
    }
    const maxSad = MINIMAP_PATCH * MINIMAP_PATCH * 0.7;
    if (bestSad >= maxSad) return;
    const centerX = (bestSx + MINIMAP_PATCH / 2) / MAP_DOWNSCALE;
    const centerY = (bestSy + MINIMAP_PATCH / 2) / mapSmallH;
    playerIconNorm.x = centerX;
    playerIconNorm.y = centerY;
    applyPlayerIconPosition();
  }

  async function startMinimapTracking() {
    stopMinimapTracking();
    minimapVideo = document.createElement("video");
    minimapVideo.autoplay = true;
    minimapVideo.muted = true;
    minimapVideo.playsInline = true;
    minimapVideo.style.cssText = "position:absolute;width:1px;height:1px;opacity:0;pointer-events:none;";
    document.body.appendChild(minimapVideo);
    let stream = null;
    try {
      if (window.api?.getGameWindowSourceId) {
        const result = await window.api.getGameWindowSourceId();
        if (result?.sourceId) {
          stream = await navigator.mediaDevices.getUserMedia({
            audio: false,
            video: {
              mandatory: {
                chromeMediaSource: "desktop",
                chromeMediaSourceId: result.sourceId
              }
            }
          });
        }
      }
      if (!stream && typeof navigator.mediaDevices.getDisplayMedia === "function") {
        stream = await navigator.mediaDevices.getDisplayMedia({
          audio: false,
          video: { displaySurface: "window" }
        });
      }
      if (!stream) {
        console.warn("Minimap tracking: no capture source. Start Project Gorgon and try again, or use Track from game minimap to pick the window.");
        minimapVideo.remove();
        minimapVideo = null;
        return;
      }
      minimapStream = stream;
      minimapVideo.srcObject = stream;
      await new Promise((resolve, reject) => {
        minimapVideo.onloadedmetadata = resolve;
        minimapVideo.onerror = reject;
        if (minimapVideo.readyState >= 1) resolve();
      });
      minimapTrackInterval = setInterval(runMinimapTrack, 800);
      updatePlayerIconVisibility();
      runMinimapTrack();
    } catch (err) {
      console.warn("Minimap tracking failed:", err);
      if (minimapVideo && minimapVideo.parentNode) minimapVideo.remove();
      minimapVideo = null;
      stopMinimapTracking();
    }
  }

  if (minimapTrackCheck) {
    minimapTrackCheck.addEventListener("change", () => {
      if (minimapTrackCheck.checked) startMinimapTracking();
      else stopMinimapTracking();
    });
  }
  window.addEventListener("beforeunload", stopMinimapTracking);

  // ===== PAN (pointer events = reliable) =====
  let dragging = false;
  let start = { px:0, py:0, x:0, y:0 };

  stage.addEventListener("pointerdown", (e) => {
    if (e.target === playerIcon || (playerIcon && playerIcon.contains(e.target))) return;
    dragging = true;
    stage.setPointerCapture(e.pointerId);
    start = { px: e.clientX, py: e.clientY, x, y };
    canvas.classList.add("dragging");
  });

  stage.addEventListener("pointermove", (e) => {
    if (!dragging) return;
    x = start.x + (e.clientX - start.px);
    y = start.y + (e.clientY - start.py);
    applyTransform();
  });

  stage.addEventListener("pointerup", () => {
    dragging = false;
    canvas.classList.remove("dragging");
  });
  stage.addEventListener("pointercancel", () => {
    dragging = false;
    canvas.classList.remove("dragging");
  });

  // ===== MOUSE-CENTERED ZOOM =====
  stage.addEventListener("wheel", (e) => {
    e.preventDefault();

    const rect = stage.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    // world coords under cursor pre-zoom
    const wx = (mx - x) / scale;
    const wy = (my - y) / scale;

    const zoomIntensity = 0.0015;
    const next = clamp(scale * (1 + (-e.deltaY * zoomIntensity)), 0.2, 3.5);

    // keep world point under cursor fixed
    x = mx - wx * next;
    y = my - wy * next;
    scale = next;

    applyTransform();
  }, { passive:false });

  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
</script>

</body>
</html>
