<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<title>Dungeon Overlay</title>
<style>
  html, body { height:100%; }
  body {
    margin:0;
    background: transparent;
    color:#fff;
    font-family:Arial, sans-serif;
    overflow:hidden;
  }

  .titlebar {
    height: 64px;
    background: rgba(0, 0, 0, 0.85);
    display:flex;
    flex-direction:column;
    padding: 8px 10px;
    -webkit-app-region: drag;
    user-select:none;
  }

  .toprow{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
  }

  .dungeon-layout {
    display: flex;
    height: calc(100vh - 64px);
    -webkit-app-region: no-drag;
  }

  .dungeon-sidebar {
    width: 160px;
    flex-shrink: 0;
    background: transparent;
    border-right: 1px solid rgba(255,255,255,0.08);
    padding: 10px;
    display: flex;
    flex-direction: column;
    gap: 14px;
  }

  .dungeon-sidebar label {
    font-size: 11px;
    color: rgba(255,255,255,0.8);
    display: block;
    margin-bottom: 4px;
  }

  .dungeon-sidebar select {
    width: 100%;
    padding: 6px 8px;
    font-size: 12px;
    background: #222;
    border: 1px solid rgba(255,255,255,0.2);
    border-radius: 8px;
    color: #fff;
    cursor: pointer;
  }

  .dungeon-sidebar select:focus {
    outline: none;
    border-color: rgba(255,204,77,0.5);
  }

  .dungeon-opacity-wrap {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .dungeon-opacity-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 8px;
  }

  .dungeon-opacity-value {
    font-size: 11px;
    color: rgba(255,255,255,0.7);
    min-width: 32px;
    text-align: right;
  }

  .dungeon-opacity-slider {
    width: 100%;
    height: 6px;
    -webkit-appearance: none;
    appearance: none;
    background: rgba(255,255,255,0.15);
    border-radius: 3px;
  }

  .dungeon-opacity-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: #ffcc4d;
    cursor: pointer;
    border: none;
  }

  .dungeon-opacity-slider::-moz-range-thumb {
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: #ffcc4d;
    cursor: pointer;
    border: none;
  }

  .btn {
    padding: 4px 8px;
    font-size: 11px;
    border-radius: 8px;
    border: 1px solid rgba(255,255,255,0.2);
    background: #222;
    color: #fff;
    cursor: pointer;
  }
  .btn:hover { background: #333; }

  .stage-wrap {
    flex: 1;
    min-width: 0;
    position: relative;
  }

  .stage {
    width: 100%;
    height: 100%;
    position: absolute;
    left: 0;
    top: 0;
    right: 0;
    bottom: 0;
    overflow: hidden;
    touch-action: none;
    background: transparent;
  }

  .canvas {
    position:absolute;
    left:0;
    top:0;
    transform-origin:0 0;
    cursor:grab;
    display:inline-block;
  }
  .canvas.dragging { cursor:grabbing; }

  .player-icon {
    position:absolute;
    width:20px;
    height:20px;
    margin-left:-10px;
    margin-top:-10px;
    border-radius:50%;
    background:#00cc66;
    border:2px solid #fff;
    box-shadow:0 0 6px rgba(0,0,0,0.8);
    cursor:grab;
    z-index:2;
  }
  .player-icon.dragging { cursor:grabbing; }
  .player-icon.hidden { display:none; }

  img {
    display:block;
    max-width:none;
    user-select:none;
    -webkit-user-drag:none;
    pointer-events:none;
  }

  .hint{
    font-size:12px;
    color:rgba(255,255,255,0.70);
    margin-top:2px;
  }

  .clickthrough-wrap {
    display: flex;
    align-items: center;
    gap: 8px;
    -webkit-app-region: no-drag;
  }
  .clickthrough-wrap label {
    font-size: 12px;
    cursor: pointer;
    user-select: none;
  }

  /* Map-only mode (F6): show "Dungeon only" strip (draggable), hide full title bar and sidebar */
  .dungeon-only-bar {
    display: none;
    height: 28px;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    color: rgba(255,255,255,0.9);
    text-shadow: 0 0 4px #000, 0 1px 2px #000;
    -webkit-app-region: drag;
    user-select: none;
  }
  body.titlebar-transparent .titlebar {
    height: 28px;
    min-height: 28px;
    padding: 0;
    background: transparent;
    justify-content: center;
  }
  body.titlebar-transparent .titlebar .toprow {
    display: none;
  }
  body.titlebar-transparent .titlebar .dungeon-only-bar {
    display: flex;
  }
  body.titlebar-transparent .dungeon-layout {
    height: calc(100vh - 28px);
  }
  body.titlebar-transparent .dungeon-sidebar {
    width: 0;
    min-width: 0;
    padding: 0;
    overflow: hidden;
    border: none;
  }
  body.titlebar-transparent .titlebar .toprow > div:first-child > div:first-child,
  body.titlebar-transparent .titlebar .hint,
  body.titlebar-transparent .titlebar .clickthrough-wrap label,
  body.titlebar-transparent .titlebar .btn {
    text-shadow: 0 0 4px #000, 0 1px 2px #000;
  }
</style>
</head>
<body tabindex="0">

<div class="titlebar">
  <div class="dungeon-only-bar" aria-hidden="true">Dungeon only</div>
  <div class="toprow">
    <div>
      <div style="font-weight:900;">Dungeons</div>
      <div class="hint">Drag to pan • Mouse wheel zooms • ESC closes • F6 show dungeon selection &amp; window • F8 click-through</div>
    </div>
    <div class="clickthrough-wrap">
      <input type="checkbox" id="clickthroughCheck" />
      <label for="clickthroughCheck">Click-through</label>
    </div>
    <button class="btn" style="-webkit-app-region:no-drag;" onclick="window.api.closeOverlay()">Close</button>
  </div>
</div>

<div class="dungeon-layout">
  <aside class="dungeon-sidebar">
    <div>
      <label for="dungeonSelect">Dungeon</label>
      <select id="dungeonSelect" aria-label="Select dungeon"></select>
    </div>
    <div>
      <button type="button" class="btn" id="setCurrentDungeonBtn" style="width:100%;">Set as current dungeon</button>
    </div>
    <div class="dungeon-opacity-wrap">
      <label for="dungeonOpacitySlider">Opacity</label>
      <div class="dungeon-opacity-row">
        <input type="range" id="dungeonOpacitySlider" class="dungeon-opacity-slider" min="30" max="100" value="100" />
        <span class="dungeon-opacity-value" id="dungeonOpacityValue">100%</span>
      </div>
    </div>
  </aside>
  <div class="stage-wrap">
    <div class="stage" id="stage">
      <div class="canvas" id="canvas">
        <img id="dungeonImage" src="" draggable="false" alt="Dungeon" />
        <div class="player-icon hidden" id="playerIcon" title="You are here" aria-hidden="true"></div>
      </div>
    </div>
  </div>
</div>

<script>
  window.addEventListener("contextmenu", (e) => e.preventDefault());
  window.addEventListener("dragstart", (e) => e.preventDefault());

  function forceFocus(){
    document.body.focus();
    window.focus();
  }
  window.addEventListener("load", forceFocus);
  window.addEventListener("focus", forceFocus);
  document.addEventListener("mousedown", forceFocus);

  window.addEventListener("keydown", (e) => {
    if (e.key === "Escape") window.api.closeOverlay();
  });

  // Click-through option (F8 toggles when overlay can't be clicked)
  const clickthroughCheck = document.getElementById("clickthroughCheck");
  if (clickthroughCheck && window.api) {
    clickthroughCheck.addEventListener("change", () => {
      window.api.setOverlayClickthrough(clickthroughCheck.checked);
    });
    window.api.onOverlayClickthroughState?.((value) => {
      clickthroughCheck.checked = !!value;
    });
  }

  // F6: title bar transparent / visible
  function setTitleBarVisible(visible) {
    document.body.classList.toggle("titlebar-transparent", !visible);
  }
  if (window.api) {
    window.api.getOverlayTitleBarVisible?.().then(setTitleBarVisible);
    window.api.onOverlayTitleBarVisible?.(setTitleBarVisible);
  }

  const DUNGEON_SIDEBAR_WIDTH = 160;

  const dungeonSelect = document.getElementById("dungeonSelect");
  const dungeonImage = document.getElementById("dungeonImage");
  const stage = document.getElementById("stage");
  const canvas = document.getElementById("canvas");
  const dungeonOpacitySlider = document.getElementById("dungeonOpacitySlider");
  const dungeonOpacityValue = document.getElementById("dungeonOpacityValue");

  let dungeons = [];
  let dungeonValues = [];
  let scale = 0.8;
  let x = 40;
  let y = 40;

  function applyTransform(){
    canvas.style.transform = `translate(${x}px, ${y}px) scale(${scale})`;
  }

  function getDungeonFile(value) {
    const entry = dungeons.find((d) => d.value === value);
    return entry ? entry.file : value + ".png";
  }

  function loadDungeon(value){
    const file = getDungeonFile(value);
    dungeonImage.onload = function(){
      if (window.api && window.api.setOverlaySize && dungeonImage.naturalWidth && dungeonImage.naturalHeight) {
        window.api.setOverlaySize(DUNGEON_SIDEBAR_WIDTH + dungeonImage.naturalWidth, dungeonImage.naturalHeight);
      }
      if (typeof loadPlayerIconPosition === "function") loadPlayerIconPosition();
    };
    dungeonImage.onerror = function() { dungeonImage.src = ""; };
    dungeonImage.src = "dungeons/" + file;
    scale = 0.8; x = 40; y = 40;
    applyTransform();
  }

  function initDungeonList(entries) {
    dungeons = entries || [];
    dungeonValues = dungeons.map((d) => d.value);
    dungeonSelect.innerHTML = "";
    dungeons.forEach((d) => {
      const opt = document.createElement("option");
      opt.value = d.value;
      opt.textContent = d.label;
      dungeonSelect.appendChild(opt);
    });
    if (dungeons.length) {
      loadDungeon(dungeons[0].value);
      dungeonSelect.value = dungeons[0].value;
    }
    if (window.api && window.api.getCurrentDungeonZone && typeof applyZoneFromApp === "function") {
      window.api.getCurrentDungeonZone().then(applyZoneFromApp);
    }
  }

  dungeonSelect.addEventListener("change", () => loadDungeon(dungeonSelect.value));

  const setCurrentDungeonBtn = document.getElementById("setCurrentDungeonBtn");
  if (setCurrentDungeonBtn && window.api?.setCurrentDungeonZone) {
    setCurrentDungeonBtn.addEventListener("click", () => {
      window.api.setCurrentDungeonZone(dungeonSelect.value);
    });
  }

  if (dungeonOpacitySlider && window.api && window.api.setOverlayOpacity) {
    dungeonOpacitySlider.addEventListener("input", () => {
      const pct = dungeonOpacitySlider.value;
      if (dungeonOpacityValue) dungeonOpacityValue.textContent = pct + "%";
      window.api.setOverlayOpacity(Number(pct) / 100);
    });
  }

  if (window.api && window.api.getDungeonFiles) {
    window.api.getDungeonFiles().then(initDungeonList);
  } else {
    initDungeonList([]);
  }

  // Player icon: position (normalized 0-1), draggable, show when dungeon matches
  const playerIcon = document.getElementById("playerIcon");
  let currentDungeonZoneFromApp = "";
  let playerIconNorm = { x: 0.5, y: 0.5 };
  let iconDragging = false;
  let iconDragStart = { px: 0, py: 0, nx: 0.5, ny: 0.5 };

  function applyPlayerIconPosition() {
    if (!playerIcon || !dungeonImage.naturalWidth || !dungeonImage.naturalHeight) return;
    const nx = Math.max(0, Math.min(1, playerIconNorm.x));
    const ny = Math.max(0, Math.min(1, playerIconNorm.y));
    playerIcon.style.left = (nx * dungeonImage.naturalWidth) + "px";
    playerIcon.style.top = (ny * dungeonImage.naturalHeight) + "px";
  }

  function updatePlayerIconVisibility() {
    if (!playerIcon) return;
    const show = currentDungeonZoneFromApp && dungeonSelect.value === currentDungeonZoneFromApp;
    playerIcon.classList.toggle("hidden", !show);
    if (show) applyPlayerIconPosition();
  }

  function loadPlayerIconPosition() {
    const zone = dungeonSelect.value;
    if (!zone || !window.api?.getPlayerIconPosition) return;
    window.api.getPlayerIconPosition("dungeon", zone).then((pos) => {
      if (pos && typeof pos.x === "number" && typeof pos.y === "number") {
        playerIconNorm.x = pos.x;
        playerIconNorm.y = pos.y;
      } else {
        playerIconNorm.x = 0.5;
        playerIconNorm.y = 0.5;
      }
      applyPlayerIconPosition();
    });
  }

  function savePlayerIconPosition() {
    const zone = dungeonSelect.value;
    if (!zone || !window.api?.setPlayerIconPosition) return;
    window.api.setPlayerIconPosition("dungeon", zone, playerIconNorm.x, playerIconNorm.y);
  }

  if (playerIcon) {
    playerIcon.addEventListener("pointerdown", (e) => {
      if (e.button !== 0 || !currentDungeonZoneFromApp || dungeonSelect.value !== currentDungeonZoneFromApp) return;
      e.preventDefault();
      e.stopPropagation();
      iconDragging = true;
      playerIcon.setPointerCapture(e.pointerId);
      playerIcon.classList.add("dragging");
      iconDragStart = { px: e.clientX, py: e.clientY, nx: playerIconNorm.x, ny: playerIconNorm.y };
    });
  }
  stage.addEventListener("pointermove", (e) => {
    if (!iconDragging || !dungeonImage.naturalWidth || !dungeonImage.naturalHeight) return;
    const dx = (e.clientX - iconDragStart.px) / scale;
    const dy = (e.clientY - iconDragStart.py) / scale;
    const w = dungeonImage.naturalWidth;
    const h = dungeonImage.naturalHeight;
    playerIconNorm.x = Math.max(0, Math.min(1, iconDragStart.nx + dx / w));
    playerIconNorm.y = Math.max(0, Math.min(1, iconDragStart.ny + dy / h));
    applyPlayerIconPosition();
  });
  stage.addEventListener("pointerup", () => {
    if (iconDragging) {
      iconDragging = false;
      playerIcon.classList.remove("dragging");
      savePlayerIconPosition();
    }
  });
  stage.addEventListener("pointercancel", () => {
    if (iconDragging) {
      iconDragging = false;
      playerIcon.classList.remove("dragging");
    }
  });

  function applyZoneFromApp(zone) {
    currentDungeonZoneFromApp = zone || "";
    if (zone && dungeonValues.includes(zone) && dungeonSelect.value !== zone) {
      dungeonSelect.value = zone;
      loadDungeon(zone);
    }
    updatePlayerIconVisibility();
    loadPlayerIconPosition();
  }
  if (window.api) {
    window.api.getCurrentDungeonZone?.().then(applyZoneFromApp);
    window.api.onCurrentDungeonZone?.(applyZoneFromApp);
    window.api.onOverlaySwitchToDungeon?.((zone) => {
      if (zone && dungeonValues.includes(zone)) {
        dungeonSelect.value = zone;
        loadDungeon(zone);
        currentDungeonZoneFromApp = zone;
        updatePlayerIconVisibility();
        loadPlayerIconPosition();
      }
    });
  }
  dungeonSelect.addEventListener("change", () => {
    updatePlayerIconVisibility();
    loadPlayerIconPosition();
  });

  // Pan
  let dragging = false;
  let start = { px:0, py:0, x:0, y:0 };

  stage.addEventListener("pointerdown", (e) => {
    if (e.target === playerIcon || (playerIcon && playerIcon.contains(e.target))) return;
    dragging = true;
    stage.setPointerCapture(e.pointerId);
    start = { px: e.clientX, py: e.clientY, x, y };
    canvas.classList.add("dragging");
  });

  stage.addEventListener("pointermove", (e) => {
    if (!dragging) return;
    x = start.x + (e.clientX - start.px);
    y = start.y + (e.clientY - start.py);
    applyTransform();
  });

  stage.addEventListener("pointerup", () => {
    dragging = false;
    canvas.classList.remove("dragging");
  });
  stage.addEventListener("pointercancel", () => {
    dragging = false;
    canvas.classList.remove("dragging");
  });

  // Zoom at cursor
  stage.addEventListener("wheel", (e) => {
    e.preventDefault();

    const rect = stage.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    const wx = (mx - x) / scale;
    const wy = (my - y) / scale;

    const zoomIntensity = 0.0015;
    const next = clamp(scale * (1 + (-e.deltaY * zoomIntensity)), 0.2, 3.5);

    x = mx - wx * next;
    y = my - wy * next;
    scale = next;

    applyTransform();
  }, { passive:false });

  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
</script>

</body>
</html>
